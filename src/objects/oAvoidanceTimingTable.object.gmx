<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>PanelX = 48;
PanelY = 88;
LineHeight = 32;
MaxLineDisplayCount = 5;
CrossRectHWidth = 20;
CrossRectHHeight = LineHeight / 2;
SelectionRectLeft = -10;
SelectionRectRight = 140;
TimingDisplayDelay = 100;

TableFreezeTiming = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var avoidance = global.ActiveAvoidance;
var step = avoidance.Step;
var timingsList = oAvoidancePersistentData.TimingsList;
var timingsCount = ds_list_size( timingsList );
if( !avoidance.IsPaused ) {
    for( var i = 0; i &lt; timingsCount; i++ ) {  
        var timing = timingsList[|i];   
        if( timing == step + 1 ) {
            play_sound( sndSnap );
            break;
        } else if( timing &gt; step ) {
             break;
        }
    }
}

if( button_check_pressed( global.AvoidanceAddTiming ) ) {
    var newTiming = step;
    for( var i = 0; i &lt; timingsCount; i++ ) {
        var timing = timingsList[|i];   
        if( timing &gt;= newTiming ) {
            ds_list_insert( timingsList, i, newTiming );
            play_sound( sndSnap );
            exit;
        }
    }
    ds_list_insert( timingsList, timingsCount, newTiming );
    play_sound( sndSnap );
}

var lMousePressed = mouse_check_button_pressed( mb_left );
var rMousePressed = mouse_check_button_pressed( mb_right );
if( lMousePressed || rMousePressed ) {
    // Find the display count.
    var displayStep = step;
    if( TableFreezeTiming != -1 ) {
       displayStep = TableFreezeTiming;
    }
    
    var count = ds_list_size( timingsList );
    var displayCount = 0;
    var firstTimingPos = 0;
    for( var i = 0; i &lt; count; i++ ) {
        var currentStep = timingsList[|i];
        if( currentStep &gt; displayStep - TimingDisplayDelay ) {
            firstTimingPos = i;
            displayCount = min( MaxLineDisplayCount + 1, count - i );
            break;
        }
    }

    var mouseLinePos = floor( ( mouse_y - PanelY + 5 ) / LineHeight );
    var timingPos = mouseLinePos + firstTimingPos;
    var lineLeft = PanelX + SelectionRectLeft;
    var lineRight = PanelX + SelectionRectRight;
    if( mouse_x &gt;= lineLeft &amp;&amp; mouse_x &lt; lineRight ) {
        if( mouseLinePos &gt;= 0 &amp;&amp; mouseLinePos &lt; displayCount ) {
            var oldTiming = timingsList[|timingPos];
            if( lMousePressed ) {
                var newTiming = get_integer( "Adjust timing", oldTiming );
                if( newTiming &gt; 0 ) {
                    // Delete the old timing and insert a new one.
                    ds_list_delete( timingsList, timingPos );
                    for( var i = 0; i &lt; timingsCount; i++ ) {
                        var timing = timingsList[|i];   
                        if( timing &gt;= newTiming ) {
                            ds_list_insert( timingsList, i, newTiming );
                            exit;
                        }
                    }
                    ds_list_add( timingsList, newTiming );
                }
            } else if( rMousePressed ) {
                avoidance_set_step( oldTiming );
                TableFreezeTiming = oldTiming;
            }
        }
    } else if( mouse_x &gt;= lineRight &amp;&amp; mouse_x &lt; lineRight + 2 * CrossRectHWidth ) {
        if( mouseLinePos &gt;= 0 &amp;&amp; mouseLinePos &lt; displayCount ) {
            if( lMousePressed ) {
                ds_list_delete( timingsList, timingPos );
            } else if( rMousePressed ) {
                var timing = timingsList[|timingPos];
                avoidance_set_step( timing );
                TableFreezeTiming = timing;
            }
        }
    }   
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var timingsList = oAvoidancePersistentData.TimingsList;
var avoidance = global.ActiveAvoidance;
var step = avoidance.Step;
if( TableFreezeTiming != -1 ) {
    step = TableFreezeTiming;
}

var count = ds_list_size( timingsList );
var displayCount = 0;
for( var i = 0; i &lt; count; i++ ) {
    var currentStep = timingsList[|i];
    if( currentStep &gt; step - TimingDisplayDelay ) {
        var timingAlpha;
        var timingColor;
        if( currentStep &lt; step ) {
            var alphaDiff = ( step - currentStep ) / TimingDisplayDelay;
            var colorDiff = ( step - currentStep ) / TimingDisplayDelay;
            timingAlpha = 1 - alphaDiff;    
            timingColor = merge_color( c_lime, c_white, colorDiff );
        } else {
            var timingPosition = clamp( ( currentStep - step ) / 5, 0, 1 );
            timingColor = merge_color( c_lime, c_white, timingPosition );
            timingAlpha = 1;
        }
        var lineY = PanelY + displayCount * LineHeight;
        var timingStr = 'Step: ' + string( currentStep );
        draw_set_alpha( timingAlpha );
        draw_text_outline( PanelX, lineY, timingStr, timingColor, c_black );
        displayCount++;
    }
    if( displayCount &gt; MaxLineDisplayCount ) {
        break;
    }
}

draw_set_alpha( 1 );
var mouseLinePos = floor( ( mouse_y - PanelY + 5 ) / LineHeight );
var lineLeft = PanelX + SelectionRectLeft;
var lineRight = PanelX + SelectionRectRight;
var lineTop = PanelY + mouseLinePos * LineHeight - 5;
var lineBottom = lineTop + LineHeight;
if( mouse_x &gt;= lineLeft &amp;&amp; mouse_x &lt; lineRight + 2 * CrossRectHWidth &amp;&amp; mouseLinePos &gt;= 0 &amp;&amp; mouseLinePos &lt; displayCount ) {
    draw_set_color( c_white );
    draw_rectangle( lineLeft, lineBottom, lineRight, lineTop, true );
    var crossX = lineRight + CrossRectHWidth;
    var crossY = ( lineBottom + lineTop ) / 2;
    var crossLeft = crossX - CrossRectHWidth;
    var crossRight = crossX + CrossRectHWidth;
    var crossTop = crossY - CrossRectHHeight;
    var crossBottom = crossY + CrossRectHHeight;
    var crossColor;
    if( abs( mouse_x - crossX ) &lt; CrossRectHWidth &amp;&amp; abs( mouse_y - crossY ) &lt; CrossRectHHeight ) {
        crossColor = c_yellow;
    } else {
        crossColor = c_white;
    }
    draw_sprite_ext( sUiCross, 0, crossX, crossY, 1, 1, 0, crossColor, 1 );
    draw_set_color( crossColor );
    draw_rectangle( crossLeft, crossBottom, crossRight, crossTop, true );
    draw_set_color( c_white );
    TableFreezeTiming = step;
} else {
    TableFreezeTiming = -1;
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
