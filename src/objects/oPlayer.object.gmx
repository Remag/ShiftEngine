<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sPlayerIdle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialization

L = 0;
R = 0;

// Instance Variables
GravityDir = 1;
gravity = 0.4;
Jump1 = 8.5;
Jump2 = 7;
OnPlatform = false;
image_speed = 0.2;
Frozen = false;
Djump = false;
Hscap = 3;
Vscap = 9;
set_mask();
Dir = 1;

// Autosaving
if( global.Autosave ) {
    save_game();
    global.Autosave = false;
}

// Custom sprites should be set here
SFall  = sPlayerFall;
SIdle  = sPlayerIdle;
SJump  = sPlayerJump;
SRun   = sPlayerRunning;
SSlide = sPlayerSliding;

sprite_index = SIdle; // Ensuring it's the right sprite from creation

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Debug: Change V-Align

if( !Frozen ) {
    if( global.Debug &amp;&amp; keyboard_check_pressed( global.VAlignDebugKeyBind ) ) {
        var vf = floor( y );
        var va = y - vf;
        var newVa = get_integer( "New V-Align:", va );
        if( newVa &gt;= 0 ) {
            y = vf + newVa;
        }
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Movement

var h = 0; // Default (player not moving)

// Checking input.
if( global.LrAnywhere ) {
    L = keyboard_check_direct( global.LeftKeyBind );
    R = keyboard_check_direct( global.RightKeyBind );
} else {
    L = keyboard_check( global.LeftKeyBind );
    R = keyboard_check( global.RightKeyBind );
}

if( !Frozen ) {
    if( R ) {
        h = 1;
    } else if( L ) {
        h = -1;
    }
}

// Collision checks.
var floorBlock = instance_place( x, y + GravityDir, oBlock );
var floorConveyor = instance_place( x, y + GravityDir, oConveyor );
var onVineL = floorBlock == noone &amp;&amp; place_meeting( x - 1, y, oVineL );
var onVineR = floorBlock == noone &amp;&amp; place_meeting( x + 1, y, oVineR );

var inWater1 = place_meeting( x, y, oWater1 );
var inWater2 = place_meeting( x, y, oWater2 );
var inWater3 = place_meeting( x, y, oWater3 );

// Movement.
if( h != 0 ) {
    // Setting the direction the player is facing.
    if( !onVineL &amp;&amp; !onVineR ) {
        Dir = h; 
    }
    // Setting speed.
    hspeed = Hscap * h; 
    // Running sprite.
    sprite_index = SRun;
    image_speed = 0.5; 
} else {
    // Stop moving.
    hspeed = 0; 
    // Idle sprite.
    sprite_index = SIdle; 
    image_speed = 0.2; 
}

if( !OnPlatform ) {
    if( vspeed * GravityDir &lt; -0.05 ) {
        sprite_index = SJump;
    } else if( vspeed * GravityDir &gt; 0.05 ) {
        sprite_index = SFall;
    }
} else {
    // Platform Magic.
    if( !place_meeting( x, y + 4 * GravityDir, oPlatform ) ) {
        OnPlatform = false;
    }
}

// Conveyor Magic.
if( floorConveyor != noone ) {
    hspeed += floorConveyor.Cspeed; 
}
// vspeed capping.
if( abs( vspeed ) &gt; Vscap ) {
    vspeed = sign( vspeed ) * Vscap; 
}

// Player controlled movement.
if( !Frozen ) {
    if( global.Debug ) {
        if( global.AdTrick &amp;&amp; floorBlock != noone ) {
            if( keyboard_check_pressed( ord( "A" ) ) ) {
                hspeed -= 1;
            } else if( keyboard_check_pressed( ord( "D" ) ) ) {
                hspeed += 1;
            }
        }
        if( keyboard_check( global.DragDebugKeyBind ) || mouse_check_button( global.DragMouseDebugKeyBind ) ) {
            x = mouse_x; 
            xprevious = x;
            y = mouse_y; 
            yprevious = y;
            vspeed = 0;
        }
    }
    if( keyboard_check_pressed( global.JumpKeyBind ) ) {
        var aboveBlock = ( floorBlock != noone );
        var abovePlatform = place_meeting( x, y + GravityDir, oPlatform );
        var touchingWater1 = inWater1 || place_meeting( x, y + GravityDir, oWater1 );
        var touchingWater2 = inWater2 || place_meeting( x, y + GravityDir, oWater2 );
        var touchingWater3 = inWater3 || place_meeting( x, y + GravityDir, oWater3 );
        if( OnPlatform || abovePlatform || aboveBlock || touchingWater1 ) {
            vspeed = -Jump1; // First jump
            Djump = true; // Make sure you can djump afterwards
            play_sound( seJump ); // Jump sound
        } else if( Djump || global.InfiniteJump || touchingWater2 || touchingWater3 ) { 
            Djump = touchingWater3;
            vspeed = -Jump2; // Doublejump
            sprite_index = SJump; // Jumping sprite
            play_sound( seJump2 ); // Djump sound
        }
    }
    if( keyboard_check_released( global.JumpKeyBind ) ) {
        if( vspeed * GravityDir &lt; 0 ) {
            // Jump released
            vspeed *= 0.45; 
        }
    }
    if( keyboard_check_pressed( global.ShootKeyBind ) ) {
        if( instance_number( oBullet ) &lt; global.BulletCap ) {
            with( instance_create( x, y, oBullet ) ) { // Create bullet
                Shooter = other.id;
                hspeed = other.Dir * 16; // Set speed (16px/f)
                alarm[0] = 40; // Destroy in 40 frames
                play_sound( seShoot ); // Play sound
            }
        }
    }
    if( global.CanSuicide &amp;&amp; keyboard_check_pressed( global.SuicideKeyBind ) ) {
        die();
    }
}

if( onVineL || onVineR ) {
    // Setting (inverse) player direction.
    if( onVineR ) {
        Dir = -1;
    } else {
        Dir = 1;
    }
    // Setting sliding speed
    vspeed = 2 * GravityDir;
    // Sliding sprite.
    sprite_index = SSlide; 
    image_speed = 0.5;
    
    if( ( onVineL &amp;&amp; keyboard_check_pressed( global.RightKeyBind ) ) ||
        ( onVineR &amp;&amp; keyboard_check_pressed( global.LeftKeyBind ) ) )
    {
        if( keyboard_check( global.JumpKeyBind ) ) {
            // Jumping off from vines.
            // Jumpoff hspeed.
            if( onVineR ) {
                hspeed = -15;
            } else {
                hspeed = 15;
            } 
            // Jumpoff vspeed.
            vspeed = -9 * GravityDir; 
            // Play vine-jump sound.
            play_sound( seJump3 ); 
            // Jumping sprite.
            sprite_index = SJump; 
        } else {
            // Falling off from vines.
            if( onVineR ) {
                hspeed = -3; 
            } else {
                hspeed = 3;
            }
            sprite_index = SFall;
        }
    }
}

// Water Physics
if( inWater1 || inWater2 || inWater3 ) {
    if( vspeed * GravityDir &gt; 2 ) {
        vspeed = 2 * GravityDir;
    }
}

// Room Edge - Death, Switching or Wrapping
if( global.WrapPlayerX ) {
    while( x &gt; room_width ) {
        x -= room_width;
    }
    while( x &lt; 0 ) {
        x += room_width;
    }
}
if( global.WrapPlayerY ) {
    while( y &gt; room_height ) {
        y -= room_height;
    }
    while( y &lt; 0 ) {
        y += room_height;
    }
}

// Check for screen edge.
if( global.KillPlayerOnEdge &amp;&amp; ( x &gt; room_width || x &lt; 0 || y &gt; room_height || y &lt; 0 ) ) {
    die();
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="oKiller">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Death

if( !global.God ) {
    die();
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="oPlatform">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Platform Magic
// It's the standard, bad implementation we all know and love.

if( GravityDir == 1 ) {
    if( y - vspeed / 2 &lt;= other.y ) {
        if( other.vspeed &gt;= 0 ) {
            y = other.y - 9;
            vspeed = other.vspeed;
            Djump = true;
        }
        OnPlatform = true;
        Djump = true;
    }
} else {
    if( y - vspeed / 2 &gt;= other.y + 15 ) {
        if( other.vspeed &gt;= 0 ) {
            y = other.y + 23;
            vspeed = other.vspeed;
            Djump = true;
        }
        OnPlatform = true;
        Djump = true;
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="oBlock">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Collision (No Solids!)

// Move back to before the kid was moved.
x = xprevious;
y = yprevious;

var horizontalCollision = ( instance_place( x + hspeed, y, oBlock ) != noone );
var verticalCollision = ( instance_place( x, y + vspeed, oBlock ) != noone );
// Snap to blocks horizontally.
if( horizontalCollision &amp;&amp; hspeed != 0 ) {
    while( instance_place( x + sign( hspeed ), y, oBlock ) == noone ) {
        x += sign( hspeed );
    }
    hspeed = 0;
}

// Snap to blocks vertically.
if( verticalCollision ) {
    if( vspeed != 0 ) {
        while( instance_place( x, y + sign( vspeed ), oBlock ) == noone ) {
            y += sign( vspeed );
        }
    }
    
    var isLanding = ( GravityDir == 1 &amp;&amp; vspeed &gt;= 0 ) || ( GravityDir == -1 &amp;&amp; vspeed &lt;= 0 );
    Djump = Djump || isLanding;
    vspeed = 0;
}

// Check if the block is positioned strictly diagonally from the kid. 
// Stop horizontal movement to avoid collision in that case.
if( !horizontalCollision &amp;&amp; !verticalCollision ) {
    hspeed = 0;
}
x += hspeed;
y += vspeed;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Drawing Self &amp; Hitbox

var xd = x;
var yd = y;
var alpha;
if( GravityDir == -1 ) {
    yd += 1.0;
}

yd = round( yd ); // crispy GM8-like rounding (mm)

if( global.God ) {
    alpha = 0.7;
} else {
    alpha = 1.0;
}

if( global.DrawPlayer ) {
    draw_sprite_ext( sprite_index, image_index, xd, yd, image_xscale * Dir,
        image_yscale * GravityDir, image_angle, image_blend, alpha );
}

if( global.DrawHitbox ) {
    draw_sprite_ext( mask_index, image_index, x, y, image_xscale,
        image_yscale, image_angle, image_blend, alpha * 0.8 );
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
